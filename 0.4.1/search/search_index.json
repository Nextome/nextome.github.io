{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Nextome SDK Documentation PhoenixSdk is an indoor positioning, mobile-ready, offline, Sdk, designed to be integrated into an existing mobile application effortlessly Ready to use Modular Features iOS Optimized Features Localize user into indoor/outdoor area thanks to low-signal Bluetooth beacons and GPS Calculate user realtime position Monitoring indoor/outdoor switching and change floor Elaborate custom road to point of interest You can also: Integrate this module into an existing app to customize UX Manipulate indoor/outdoor user's position coordinate freely Nextome SDK - Android Resources Android Docs | Changelog | Example Project NEXTOME SDK - iOS Resources iOS Docs | Changelog | Example Project FLUTTER MAP - Resources Android | iOS | Changelog","title":"Introductin"},{"location":"#nextome-sdk-documentation","text":"PhoenixSdk is an indoor positioning, mobile-ready, offline, Sdk, designed to be integrated into an existing mobile application effortlessly Ready to use Modular Features iOS Optimized Features Localize user into indoor/outdoor area thanks to low-signal Bluetooth beacons and GPS Calculate user realtime position Monitoring indoor/outdoor switching and change floor Elaborate custom road to point of interest You can also: Integrate this module into an existing app to customize UX Manipulate indoor/outdoor user's position coordinate freely","title":"Nextome SDK Documentation"},{"location":"#nextome-sdk-android-resources","text":"Android Docs | Changelog | Example Project","title":"Nextome SDK - Android Resources"},{"location":"#nextome-sdk-ios-resources","text":"iOS Docs | Changelog | Example Project","title":"NEXTOME SDK - iOS Resources"},{"location":"#flutter-map-resources","text":"Android | iOS | Changelog","title":"FLUTTER MAP - Resources"},{"location":"Flutter%20Map/","text":"Flutter Map - Changelog 1.2.0 Features Add ability to change user position icon Add navigation FAB It's possible to show an optional fab at the bottom right of the map. When clicked, the button will: center the map on the user position; follow the user position live on map; rotate the map based on user compass; To integrate those feature, check the relative Android and iOS documentation.","title":"Changelog"},{"location":"Flutter%20Map/#flutter-map-changelog","text":"","title":"Flutter Map - Changelog"},{"location":"Flutter%20Map/#120","text":"","title":"1.2.0"},{"location":"Flutter%20Map/#features","text":"","title":"Features"},{"location":"Flutter%20Map/#add-ability-to-change-user-position-icon","text":"","title":"Add ability to change user position icon"},{"location":"Flutter%20Map/#add-navigation-fab","text":"It's possible to show an optional fab at the bottom right of the map. When clicked, the button will: center the map on the user position; follow the user position live on map; rotate the map based on user compass; To integrate those feature, check the relative Android and iOS documentation.","title":"Add navigation FAB"},{"location":"Nextome%20SDK/introduction/","text":"Nextome SDK Documentation PhoenixSdk is an indoor positioning, mobile-ready, offline, Sdk, designed to be integrated into an existing mobile application effortlessly Ready to use Modular Features iOS Optimized Features Localize user into indoor/outdoor area thanks to low-signal Bluetooth beacons and GPS Calculate user realtime position Monitoring indoor/outdoor switching and change floor Elaborate custom road to point of interest You can also: Integrate this module into an existing app to customize UX Manipulate indoor/outdoor user's position coordinate freely Android Resources Android Docs | Changelog | Example Project iOS Resources iOS Docs | Changelog | Example Project","title":"Introduction"},{"location":"Nextome%20SDK/introduction/#nextome-sdk-documentation","text":"PhoenixSdk is an indoor positioning, mobile-ready, offline, Sdk, designed to be integrated into an existing mobile application effortlessly Ready to use Modular Features iOS Optimized Features Localize user into indoor/outdoor area thanks to low-signal Bluetooth beacons and GPS Calculate user realtime position Monitoring indoor/outdoor switching and change floor Elaborate custom road to point of interest You can also: Integrate this module into an existing app to customize UX Manipulate indoor/outdoor user's position coordinate freely","title":"Nextome SDK Documentation"},{"location":"Nextome%20SDK/introduction/#android-resources","text":"Android Docs | Changelog | Example Project","title":"Android Resources"},{"location":"Nextome%20SDK/introduction/#ios-resources","text":"iOS Docs | Changelog | Example Project","title":"iOS Resources"},{"location":"Nextome%20SDK/Android/changelog/","text":"Nextome Android SDK - Changelog 0.4.1 Bugfix Fix issue with timestamps when sending live positions; 0.4.0 Features Add support for events; You can observe onEnter and onExit from event radius on map using those two observers: nextomeSdk . enterEventObservable . observe ( this ) { event -> Log . d ( \"event_test\" , \"Received on enter with data: ${ event . data } \" ) } nextomeSdk . exitEventObservable . observe ( this ) { event -> Log . d ( \"event_test\" , \"Received on exit with data: ${ event . data } \" ) } Optionally, after exiting from event, it's possible to set a timeout value in seconds before signaling that event again. If set to 0, Nextome SDK will signal onEnter and onExit event realtime. nextomeSdk = NextomePhoenixSdk (). Builder ( applicationContext ) . withEventTimeoutDurationInSeconds ( 10L ) 0.3.1 Bug fixing Fix bug when the correct bundle was not injected in request headers correctly; Throw descriptive exception when developer key, secret or bundle are not added to SDK; 0.3.0 Features Add method to get venue resources; In observer: nextomeSdk . stateLiveData . observe ( this , { when ( it . state ) { NextomePhoenixState . RUNNING -> { val poiList = it . venueResources . allPois val poiOfTheCurrentFloor = it . venueResources . getPoisByMapId ( it . mapId ) val mapsInTheVenue = it . venueResources . maps } else -> { } } }) As a single method call: val resources = nextomeSdk . state . venueResources Note that you can only retreive resources when Nextome SDK State is RUNNING. Otherwhise, nextomeSdk.state.valueResources will return a null object. Add method to get current sdk state; val currentState = nextomeSdk . state Deprecated methods nextomeSdk.currentState.asLiveData() is now deprecated. Use nextomeSdk.stateLiveData instead; state.poisOfMap is now deprecated. Use state.venueResources.getPoisByMapId(mapId) instead; state.allPois is now deprecated. Use state.venueResources.getAllPois() instead; 0.2.8 Add method to send locations to server: kotlin NextomePhoenixSdk().Builder(applicationContext) .withSendPositionToServer(true) 0.2.7 Fix issue in Event's radius parser; Add debug tools to log on file: startLoggingOnFile() and stopAndShareLog(context) 0.2.2 Expose current map POIs in observer; 0.2.1 Add new setForcedMap and setLiveMap methods. Improvements to Flutter map; 0.1.2 Fix issue with floor and map Id; Fix issue with outdoor state; 0.1.1 Added mapId and floorId in NextomePosition. You can now listen for map and floor changes using the localizationLiveData. nextomeSdk . localizationLiveData . observe ( this , Observer { val floor = it . floorId val map = it . mapId log ( \"User Position is ${ it . x } , ${ it . y } \" ) }) 0.1.0 Initial release;","title":"Android Changelog"},{"location":"Nextome%20SDK/Android/changelog/#nextome-android-sdk-changelog","text":"","title":"Nextome Android SDK - Changelog"},{"location":"Nextome%20SDK/Android/changelog/#041","text":"","title":"0.4.1"},{"location":"Nextome%20SDK/Android/changelog/#bugfix","text":"Fix issue with timestamps when sending live positions;","title":"Bugfix"},{"location":"Nextome%20SDK/Android/changelog/#040","text":"","title":"0.4.0"},{"location":"Nextome%20SDK/Android/changelog/#features","text":"Add support for events; You can observe onEnter and onExit from event radius on map using those two observers: nextomeSdk . enterEventObservable . observe ( this ) { event -> Log . d ( \"event_test\" , \"Received on enter with data: ${ event . data } \" ) } nextomeSdk . exitEventObservable . observe ( this ) { event -> Log . d ( \"event_test\" , \"Received on exit with data: ${ event . data } \" ) } Optionally, after exiting from event, it's possible to set a timeout value in seconds before signaling that event again. If set to 0, Nextome SDK will signal onEnter and onExit event realtime. nextomeSdk = NextomePhoenixSdk (). Builder ( applicationContext ) . withEventTimeoutDurationInSeconds ( 10L )","title":"Features"},{"location":"Nextome%20SDK/Android/changelog/#031","text":"","title":"0.3.1"},{"location":"Nextome%20SDK/Android/changelog/#bug-fixing","text":"Fix bug when the correct bundle was not injected in request headers correctly; Throw descriptive exception when developer key, secret or bundle are not added to SDK;","title":"Bug fixing"},{"location":"Nextome%20SDK/Android/changelog/#030","text":"","title":"0.3.0"},{"location":"Nextome%20SDK/Android/changelog/#features_1","text":"Add method to get venue resources; In observer: nextomeSdk . stateLiveData . observe ( this , { when ( it . state ) { NextomePhoenixState . RUNNING -> { val poiList = it . venueResources . allPois val poiOfTheCurrentFloor = it . venueResources . getPoisByMapId ( it . mapId ) val mapsInTheVenue = it . venueResources . maps } else -> { } } }) As a single method call: val resources = nextomeSdk . state . venueResources Note that you can only retreive resources when Nextome SDK State is RUNNING. Otherwhise, nextomeSdk.state.valueResources will return a null object. Add method to get current sdk state; val currentState = nextomeSdk . state","title":"Features"},{"location":"Nextome%20SDK/Android/changelog/#deprecated-methods","text":"nextomeSdk.currentState.asLiveData() is now deprecated. Use nextomeSdk.stateLiveData instead; state.poisOfMap is now deprecated. Use state.venueResources.getPoisByMapId(mapId) instead; state.allPois is now deprecated. Use state.venueResources.getAllPois() instead;","title":"Deprecated methods"},{"location":"Nextome%20SDK/Android/changelog/#028","text":"Add method to send locations to server: kotlin NextomePhoenixSdk().Builder(applicationContext) .withSendPositionToServer(true)","title":"0.2.8"},{"location":"Nextome%20SDK/Android/changelog/#027","text":"Fix issue in Event's radius parser; Add debug tools to log on file: startLoggingOnFile() and stopAndShareLog(context)","title":"0.2.7"},{"location":"Nextome%20SDK/Android/changelog/#022","text":"Expose current map POIs in observer;","title":"0.2.2"},{"location":"Nextome%20SDK/Android/changelog/#021","text":"Add new setForcedMap and setLiveMap methods. Improvements to Flutter map;","title":"0.2.1"},{"location":"Nextome%20SDK/Android/changelog/#012","text":"Fix issue with floor and map Id; Fix issue with outdoor state;","title":"0.1.2"},{"location":"Nextome%20SDK/Android/changelog/#011","text":"Added mapId and floorId in NextomePosition. You can now listen for map and floor changes using the localizationLiveData. nextomeSdk . localizationLiveData . observe ( this , Observer { val floor = it . floorId val map = it . mapId log ( \"User Position is ${ it . x } , ${ it . y } \" ) })","title":"0.1.1"},{"location":"Nextome%20SDK/Android/changelog/#010","text":"Initial release;","title":"0.1.0"},{"location":"Nextome%20SDK/Android/integration/","text":"Nextome Android SDK - Android Integration Guide A full working example app is available on this repository . Run the MapActivity to see Nextome Sdk in action. It also contains a seamless outdoor/indoor map integration using OpenStreetMap for outdoor and Nextome Flutter Map for indoor. How to include Add our repositories in root build.gradle : root/build.gradle allprojects { repositories { ... maven { url \"https://nextome.jfrog.io/artifactory/nextome-libs-release-local\" credentials { username = $USERNAME password = $PASSWORD } } maven { url 'https://jitpack.io' } } } Note Contact Nextome to receive a valid username/password to access our repository. Add the SDK dependency in app\u2019s build.gradle : project/build.gradle implementation ( 'net.nextome.phoenix_sdk:phoenix-sdk:{last_version}' ) Check latest released version here Optional Dependencies If you plan to display a live map to the user, add our Flutter MapView plugin: Add Flutter repository in root build.gradle : root/build.gradle allprojects { repositories { ... maven { url 'https://storage.googleapis.com/download.flutter.io' } } } Add Flutter Map SDK dependency in app's build.gradle app/build.gradle implementation ( 'net.nextome.nextome_map_module:flutter_release:{last_version}' ) Check latest released version here change me Getting started Required permissions To run, Nextome SDK requires the following permissions: <uses-permission android:name= \"android.permission.INTERNET\" /> <uses-permission android:name= \"android.permission.BLUETOOTH\" /> <uses-permission android:name= \"android.permission.BLUETOOTH_ADMIN\" /> <uses-permission android:name= \"android.permission.FOREGROUND_SERVICE\" /> <uses-permission android:name= \"android.permission.ACCESS_FINE_LOCATION\" /> <uses-permission android:name= \"android.permission.ACCESS_BACKGROUND_LOCATION\" /> Note Those are required to: Contact the backend server; Activate and manage Bluetooth beacon scan; Run as a foreground service for background mode; Access Bluetooth API (location) SDK Builder To use Nextome SDK for Android, a builder is available with some options you can customize. The basic configuration only needs your application context , the given developer key , the secret and bundle . nextomeSdk = NextomePhoenixSdk (). Builder ( applicationContext ) . withSecret ( secret ) . withDeveloperKey ( developerKey ) . withBundle ( bundle ) . build () Other optional parameters are also available. Here's a list of the customization available and a short description of them. Scanner parameters The longer you wait between scans, the longer it will take to detect a beacon. And the more reduce the length of the scan, the more likely it is that you might miss an advertisement from an beacon. You can optionally customize scan period and scan duration: . withForegroundScanPeriod ( scanPeriod ) ` sets a time in millis for the bluetooth beacon scan duration when in foreground mode. Default value is 1000 ms . withForegroundBetweenScanPeriod ( betweenScanPeriod ) ` sets a time in millis to wait between bluetooth scans when in foreground mode. Default value is 250 ms . . withBackgroundScanPeriod ( scanPeriod ) ` sets a time in millis for the bluetooth beacon scan duration when in backgorund mode. Default value is 1000 ms . withBackgroundBetweenScanPeriod ( betweenScanPeriod ) ` sets a time in millis to wait between bluetooth scans when in background mode. Default value is 250 ms . Other optional parameters . withRssiThreshold ( rssiThreshold ) ` ignore beacons below a custom RSSI threshold. Default value is -75 . . withBeaconListMaxSize ( n ) ` keeps in memory a cache of n RSSI entries in time for each beacon to more accurately compute user position. Default value is 12 . withLocalizationMethod ( localizationMethod ) ` Sets the algorithm for localization. Choises are LINEAR_SVD, NON_LINEAR_DA, PARTICLE . Default value is LINEAR_SVD . withForcedVenue ( venueId ) This allows you to skip the search for venue phase and automatically download resurces of a specific venue when Nextome starts. With this, you can force your app to open only your venue and download venue resurces even if you're not in range of your venue beacons. . withSendPositionToServer ( enabled ) This allows you to automatically send positions to Nextome server and track monitor devices realtime on the web manager. Default value is false . withEventTimeoutDurationInSeconds ( 0L ) This allows you to ignore when user exits and enters again in a event radius in a short time span. For example, if timeout is set to 60 seconds, the same event onEnter after onExit is received will be not triggered again for at least for 1 minute. Default value is 0 seconds (realtime). Start localization To start localization, call: nextomeSdk . start () If you want Nextome to keep track of user indoor position also while the phone screen is off or your app is in background, call this method instead: nextomeSdk . startForegroundService ( serviceCode , notification ) In this case, a service code and a notification is also required. The ongoing notification will be displayed while Nextome SDK runs in background mode. Observe user position Nextome SDK offers two different observers to notify user position. nextomeSdk.localizationLiveData will notify indoor user position,with info about: x , y coordinates of the user relative to the indoor map; mapId and floorId of the current user position; nextomeSdk.outdoorLocalizationLiveData will notify outdoor user position, with its latitude and longitde . Usage example: nextomeSdk . localizationLiveData . observe ( this , { log ( \"Got indoor position ( ${ it . x } , ${ it . y } ), on map ${ it . mapId } in floor ${ it . floorId } )\" ) }) nextomeSdk . outdoorLocalizationLiveData . observe ( this , { log ( \"Got outdoor position ( ${ it . lat } , ${ it . lng } )\" ) }) Observe SDK status It's possibile to observe the current state the Nextome SDK, in the localization process. You can use this data to start initializing the map or showing messages to the users and update your UI accordingly. nextomeSdk . stateLiveData . observe () The exposed information are: isOutdoor : indicates if the SDK is running in outdoor or indoor mode; tiles : local path on device of map tiles. You can use this info to initialize a map (for example, our Flutter map) to show the map to the user; mapHeight : the height in pixel of the currentmap; mapWidth : the width in pixel of the current map; venueResources : resources associated with the venue (list of maps, pois, events...); state Nextome SDK state. Nextome SDK State Nextome State is a simple state machine that can have those states: - STARTED : Nextome has been correctly initialized and it's ready to scan beacons; - SEARCH_VENUE : Nextome is currently scanning nearby beacons to determine in which venue the user is; If the SDK is stuck here, you're probably outdoor. - GET_PACKET : Nextome knows the venue of the user and it's downloading from the server the associated resources (Maps, POIs, Patches...); - FIND_FLOOR : All the venue resoruces have been downloaded. Nextome is now computing in which floor the user is; - RUNNING : Nextome SDK is computing user positions. You can observe live user location using the observer nextomeSdk.locationLiveData; Note Map tiles , venueResources , height and width are only available in the RUNNING state (when Nextome has recognized or has been forced the venue and the map where the user is); Otherwhise, they return null . If the user changes floor , the SDK will resume from FIND_FLOOR state. If the user goes outdoor , the SDK will switch to SEARCH_VENUE state until a new indoor beacon is detected. Get venue resources You can optionally ask the SDK for the local resources downloaded with your venue (those resources include maps, pois, beacons events...). There are two ways of doing this. In the state observer: nextomeSdk . stateLiveData . observe ( this , { when ( it . state ) { NextomePhoenixState . RUNNING -> { val poiList = it . venueResources . allPois val poiOfTheCurrentFloor = it . venueResources . getPoisByMapId ( it . mapId ) val mapsInTheVenue = it . venueResources . maps } else -> { } } }) as a single method call: val resources = nextomeSdk . state . venueResources Note You can only retreive resources when Nextome SDK State is RUNNING . Otherwhise, nextomeSdk.state.valueResources will return a null object. Example nextomeSdk . stateLiveData . observe ( this , { if ( it . isOutdoor ) { showOpenStreetMap () } else { showIndoorMap () } when ( it . state ) { NextomePhoenixState . STARTED -> { updateState ( \"Sdk Started\" ) } NextomePhoenixState . SEARCH_VENUE -> { updateState ( \"Searching Venue...\" ) } NextomePhoenixState . GET_PACKET -> { updateState ( \"Downloading packet...\" ) } NextomePhoenixState . FIND_FLOOR -> { updateState ( \"Finding current Floor...\" ) } NextomePhoenixState . RUNNING -> { updateState ( \"Loading map...\" ) with ( it ) { setIndoorMap ( mapTilesUrl , mapHeight , mapWidth , venueResources . getPoisByMapId ( mapId )) } } } }) Observe SDK errors You can be notified of SDK errors using the appropriate observer: nextomeSdk . errorObservable . observe ( this ) { notifyException ( it . exception ) } Force a specific map This is expecially useful when using the Flutter Map Module. With this method you can force Nextome to show a specific map, indipendently from the user real indoor location. When this method is called, Nextome will stop sending indoor location updates. You can force a map using: nextomeSdk . setForcedMap ( mapId ) Nextome will immediatly fire a status change, localizing the user at the specified map and offering map information like tiles , height and width that you can pass to the map module. When you're done and you want to observe user real location again, call: nextomeSdk . setLiveMap () Example // Force map 42 nextomeSdk.setForcedMap(42) nextomeSdk.stateLiveData.observe(this, { when (it.state) { NextomePhoenixState.RUNNING -> { with(it) { // After forcing the map, here you can pick tiles, height and width of map 42. setIndoorMap(mapTilesUrl, mapHeight, mapWidth, venueResources.getPoisByMapId(mapId)) } } } }) Calcualte path Nextome Sdk is able to calculate the shortest path between two points of the same venue. The function takes (x, y) coordinates and map of the starting point and (x, y) coordinates and map of the destination point. val path = nextomeSdk . findPath ( startX . toInt (), startY . toInt (), startMapId , targetX . toInt (), targetY . toInt (), targetMapId ) The returned path is a list of ordered Vertex, that, for example, can be passed to the Flutter Map Module and displayed to the user (see the methods written below). Observe events Info Available from nexome-sdk > 0.4.0 If events are set up in your venue, you can observe when user enters or exits from event radius using those two observers: nextomeSdk . enterEventObservable . observe ( this ) { event -> Log . d ( \"event_test\" , \"Received on enter with data: ${ event . data } \" ) } nextomeSdk . exitEventObservable . observe ( this ) { event -> Log . d ( \"event_test\" , \"Received on exit with data: ${ event . data } \" ) } Optionally, after exiting from event, it's possible to set a timeout value in seconds before signaling that event again. This allows you to ignore when user exits and enters again in a event radius in a short time span. For example, if timeout is set to 60 seconds, the same event onEnter after onExit is received will be not triggered again for at least for 1 minute. If set to 0, Nextome SDK will signal onEnter and onExit event realtime. nextomeSdk = NextomePhoenixSdk (). Builder ( applicationContext ) . withEventTimeoutDurationInSeconds ( 10L ) Flutter Map Module If you want, there's an optional module build with Flutter that can show a live map of the indoor location of the user. To use it, include the gradle dependency as written before in the How to include section. Flutter Init A little of boilerplate code is required to initialize and set up a channel between Flutter and the native app. You can just paste this code and run it before showing the map to the user. private fun initFlutter () { val appId = \"com.nextome.test\" val engine = FlutterEngine ( this ) // Start executing Dart code in the FlutterEngine. engine . dartExecutor . executeDartEntrypoint ( DartExecutor . DartEntrypoint . createDefault () ) // Cache the pre-warmed FlutterEngine to be used later by FlutterFragment. FlutterEngineCache . getInstance () . put ( appId , engine ) val fragmentManager : FragmentManager = supportFragmentManager // Attempt to find an existing FlutterFragment, in case this is not the // first time that onCreate() was run. flutterFragment = fragmentManager . findFragmentByTag ( TAG_FLUTTER_FRAGMENT ) as FlutterFragment? // Create and attach a FlutterFragment if one does not exist. if ( flutterFragment == null ) { var newFlutterFragment = FlutterFragment . withCachedEngine ( appId ). build < FlutterFragment > () flutterFragment = newFlutterFragment fragmentManager . beginTransaction () . add ( R . id . indoor_map , newFlutterFragment , TAG_FLUTTER_FRAGMENT ). commit () } channel = MethodChannel ( engine . dartExecutor , appId ) } Flutter Utils An utility class is available to help you with Flutter operations. If you want to comunicate with Flutter, it's suggested to include this class in your project. Show a new indoor map Once a map is available, pass the tiles local directory, height and width` of the map to Flutter: private fun setIndoorMap ( mapTilesUrl : String , mapHeight : Int , mapWidth : Int ) { channel . invokeMethod ( \"localPackageUrl\" , \" $ mapTilesUrl , $ mapHeight , $ mapWidth , 3\" ) } Update user live position When a new indoor user position is available, notify Flutter with: private fun updatePositionOnFlutterMap ( it : NextomePosition ) { channel . invokeMethod ( \"localPackageUrl\" , FlutterUtils . getLocalPackagePayload ( mapTilesUrl , mapHeight , mapWidth )) } Add a POI You can add custom Point of Interest on the Flutter map using this method: private fun showPoiOnMap ( poiList : List < NextomePoi > ) { channel . invokeMethod ( \"POI\" , FlutterUtils . getPoiPayload ( poiList )) } Show a custom patch You can show a path on the map using this method and passing a list of Vertex. You can automatically get the Vertext between a start and end point of the map using the appropriate method on the nextomeSdk : private fun showPathOnMap ( path : List < Vertex > ) { channel . invokeMethod ( \"path\" , FlutterUtils . getPathPayload ( path )) } Observe events on Flutter Map With this observer you can be notified of events on the Flutter map, for example, when the user decides to navigate to a POI. private fun observeMapEvents () { channel . setMethodCallHandler { methodCall , _ -> // On POI \"Navigate to\" tapped if ( methodCall . method == \"poiData\" ) { val poiSerialized = methodCall . arguments as String val poi = Gson (). fromJson ( poiSerialized , FlutterPoi :: class . java ) // Ex. calculate path to POI and show it to user showPathOnMap ( lastPosition . x , lastPosition . y lastPosition . mapId , poi . x !! , poi . y !! , poi . map !! ) } } } Show Center Position Fab Available from flutter-map > 1.2.0 It's possible to show an optional fab at the bottom right of the map. When clicked, the button will: * center the map on the user position; * follow the user position live on map; * rotate the map based on user compass; To enable the button, use: channel . invokeMethod ( \"showCenterPositionFab\" , \"true\" ) or, if you have imported our Flutter Utils : FlutterUtils . setMapViewSettings ( channel , fabEnabled = true ) please note The compass feature will only work if the app has the following permissions: android.permission.INTERNET android.permission.ACCESS_COARSE_LOCATION android.permission.ACCESS_FINE_LOCATION If those permissions are not denied, the navigation button will only follow user position without rotating. Change user position icon Info Available from flutter-map > 1.2.0 The default position icon is a blue dot. If you want to change the icon, you can load a remote resource from an url. channel . invokeMethod ( \"customPositionResourceUrl\" , \"http://nextome.net/position-icon.png\" ) or, if you're imported our Flutter Utils : FlutterUtils . setMapViewSettings ( channel , customPositionResourceUrl = \"http://nextome.net/position-icon.png\" ) Debug tools In case of necessity, Nextome SDK can write logs with useful info to a file. You can start writing logs with nextomeSdk.startLoggingOnFile() . Those logs can then be shared using nextomeSdk.stopAndShareLog(context) . A new Intent will be fired with a share dialog that allows to export and save the logs with other apps. Examples A full working example app is available on this repository. Run the MapActivity to see Nextome Sdk in action. It also contains a seamless outdoor/indoor map integration using OpenStreetMap for outdoor and Nextome Flutter Map for indoor. \u00a9 2021 Nextome srl | All Rights Reserved.","title":"Android Integration"},{"location":"Nextome%20SDK/Android/integration/#nextome-android-sdk-android-integration-guide","text":"A full working example app is available on this repository . Run the MapActivity to see Nextome Sdk in action. It also contains a seamless outdoor/indoor map integration using OpenStreetMap for outdoor and Nextome Flutter Map for indoor.","title":"Nextome Android SDK - Android Integration Guide"},{"location":"Nextome%20SDK/Android/integration/#how-to-include","text":"Add our repositories in root build.gradle : root/build.gradle allprojects { repositories { ... maven { url \"https://nextome.jfrog.io/artifactory/nextome-libs-release-local\" credentials { username = $USERNAME password = $PASSWORD } } maven { url 'https://jitpack.io' } } } Note Contact Nextome to receive a valid username/password to access our repository. Add the SDK dependency in app\u2019s build.gradle : project/build.gradle implementation ( 'net.nextome.phoenix_sdk:phoenix-sdk:{last_version}' ) Check latest released version here","title":"How to include"},{"location":"Nextome%20SDK/Android/integration/#optional-dependencies","text":"If you plan to display a live map to the user, add our Flutter MapView plugin: Add Flutter repository in root build.gradle : root/build.gradle allprojects { repositories { ... maven { url 'https://storage.googleapis.com/download.flutter.io' } } } Add Flutter Map SDK dependency in app's build.gradle app/build.gradle implementation ( 'net.nextome.nextome_map_module:flutter_release:{last_version}' ) Check latest released version here change me","title":"Optional Dependencies"},{"location":"Nextome%20SDK/Android/integration/#getting-started","text":"","title":"Getting started"},{"location":"Nextome%20SDK/Android/integration/#required-permissions","text":"To run, Nextome SDK requires the following permissions: <uses-permission android:name= \"android.permission.INTERNET\" /> <uses-permission android:name= \"android.permission.BLUETOOTH\" /> <uses-permission android:name= \"android.permission.BLUETOOTH_ADMIN\" /> <uses-permission android:name= \"android.permission.FOREGROUND_SERVICE\" /> <uses-permission android:name= \"android.permission.ACCESS_FINE_LOCATION\" /> <uses-permission android:name= \"android.permission.ACCESS_BACKGROUND_LOCATION\" /> Note Those are required to: Contact the backend server; Activate and manage Bluetooth beacon scan; Run as a foreground service for background mode; Access Bluetooth API (location)","title":"Required permissions"},{"location":"Nextome%20SDK/Android/integration/#sdk-builder","text":"To use Nextome SDK for Android, a builder is available with some options you can customize. The basic configuration only needs your application context , the given developer key , the secret and bundle . nextomeSdk = NextomePhoenixSdk (). Builder ( applicationContext ) . withSecret ( secret ) . withDeveloperKey ( developerKey ) . withBundle ( bundle ) . build () Other optional parameters are also available. Here's a list of the customization available and a short description of them.","title":"SDK Builder"},{"location":"Nextome%20SDK/Android/integration/#scanner-parameters","text":"The longer you wait between scans, the longer it will take to detect a beacon. And the more reduce the length of the scan, the more likely it is that you might miss an advertisement from an beacon. You can optionally customize scan period and scan duration: . withForegroundScanPeriod ( scanPeriod ) ` sets a time in millis for the bluetooth beacon scan duration when in foreground mode. Default value is 1000 ms . withForegroundBetweenScanPeriod ( betweenScanPeriod ) ` sets a time in millis to wait between bluetooth scans when in foreground mode. Default value is 250 ms . . withBackgroundScanPeriod ( scanPeriod ) ` sets a time in millis for the bluetooth beacon scan duration when in backgorund mode. Default value is 1000 ms . withBackgroundBetweenScanPeriod ( betweenScanPeriod ) ` sets a time in millis to wait between bluetooth scans when in background mode. Default value is 250 ms .","title":"Scanner parameters"},{"location":"Nextome%20SDK/Android/integration/#other-optional-parameters","text":". withRssiThreshold ( rssiThreshold ) ` ignore beacons below a custom RSSI threshold. Default value is -75 . . withBeaconListMaxSize ( n ) ` keeps in memory a cache of n RSSI entries in time for each beacon to more accurately compute user position. Default value is 12 . withLocalizationMethod ( localizationMethod ) ` Sets the algorithm for localization. Choises are LINEAR_SVD, NON_LINEAR_DA, PARTICLE . Default value is LINEAR_SVD . withForcedVenue ( venueId ) This allows you to skip the search for venue phase and automatically download resurces of a specific venue when Nextome starts. With this, you can force your app to open only your venue and download venue resurces even if you're not in range of your venue beacons. . withSendPositionToServer ( enabled ) This allows you to automatically send positions to Nextome server and track monitor devices realtime on the web manager. Default value is false . withEventTimeoutDurationInSeconds ( 0L ) This allows you to ignore when user exits and enters again in a event radius in a short time span. For example, if timeout is set to 60 seconds, the same event onEnter after onExit is received will be not triggered again for at least for 1 minute. Default value is 0 seconds (realtime).","title":"Other optional parameters"},{"location":"Nextome%20SDK/Android/integration/#start-localization","text":"To start localization, call: nextomeSdk . start () If you want Nextome to keep track of user indoor position also while the phone screen is off or your app is in background, call this method instead: nextomeSdk . startForegroundService ( serviceCode , notification ) In this case, a service code and a notification is also required. The ongoing notification will be displayed while Nextome SDK runs in background mode.","title":"Start localization"},{"location":"Nextome%20SDK/Android/integration/#observe-user-position","text":"Nextome SDK offers two different observers to notify user position. nextomeSdk.localizationLiveData will notify indoor user position,with info about: x , y coordinates of the user relative to the indoor map; mapId and floorId of the current user position; nextomeSdk.outdoorLocalizationLiveData will notify outdoor user position, with its latitude and longitde . Usage example: nextomeSdk . localizationLiveData . observe ( this , { log ( \"Got indoor position ( ${ it . x } , ${ it . y } ), on map ${ it . mapId } in floor ${ it . floorId } )\" ) }) nextomeSdk . outdoorLocalizationLiveData . observe ( this , { log ( \"Got outdoor position ( ${ it . lat } , ${ it . lng } )\" ) })","title":"Observe user position"},{"location":"Nextome%20SDK/Android/integration/#observe-sdk-status","text":"It's possibile to observe the current state the Nextome SDK, in the localization process. You can use this data to start initializing the map or showing messages to the users and update your UI accordingly. nextomeSdk . stateLiveData . observe () The exposed information are: isOutdoor : indicates if the SDK is running in outdoor or indoor mode; tiles : local path on device of map tiles. You can use this info to initialize a map (for example, our Flutter map) to show the map to the user; mapHeight : the height in pixel of the currentmap; mapWidth : the width in pixel of the current map; venueResources : resources associated with the venue (list of maps, pois, events...); state Nextome SDK state.","title":"Observe SDK status"},{"location":"Nextome%20SDK/Android/integration/#nextome-sdk-state","text":"Nextome State is a simple state machine that can have those states: - STARTED : Nextome has been correctly initialized and it's ready to scan beacons; - SEARCH_VENUE : Nextome is currently scanning nearby beacons to determine in which venue the user is; If the SDK is stuck here, you're probably outdoor. - GET_PACKET : Nextome knows the venue of the user and it's downloading from the server the associated resources (Maps, POIs, Patches...); - FIND_FLOOR : All the venue resoruces have been downloaded. Nextome is now computing in which floor the user is; - RUNNING : Nextome SDK is computing user positions. You can observe live user location using the observer nextomeSdk.locationLiveData; Note Map tiles , venueResources , height and width are only available in the RUNNING state (when Nextome has recognized or has been forced the venue and the map where the user is); Otherwhise, they return null . If the user changes floor , the SDK will resume from FIND_FLOOR state. If the user goes outdoor , the SDK will switch to SEARCH_VENUE state until a new indoor beacon is detected.","title":"Nextome SDK State"},{"location":"Nextome%20SDK/Android/integration/#get-venue-resources","text":"You can optionally ask the SDK for the local resources downloaded with your venue (those resources include maps, pois, beacons events...). There are two ways of doing this. In the state observer: nextomeSdk . stateLiveData . observe ( this , { when ( it . state ) { NextomePhoenixState . RUNNING -> { val poiList = it . venueResources . allPois val poiOfTheCurrentFloor = it . venueResources . getPoisByMapId ( it . mapId ) val mapsInTheVenue = it . venueResources . maps } else -> { } } }) as a single method call: val resources = nextomeSdk . state . venueResources Note You can only retreive resources when Nextome SDK State is RUNNING . Otherwhise, nextomeSdk.state.valueResources will return a null object.","title":"Get venue resources"},{"location":"Nextome%20SDK/Android/integration/#example","text":"nextomeSdk . stateLiveData . observe ( this , { if ( it . isOutdoor ) { showOpenStreetMap () } else { showIndoorMap () } when ( it . state ) { NextomePhoenixState . STARTED -> { updateState ( \"Sdk Started\" ) } NextomePhoenixState . SEARCH_VENUE -> { updateState ( \"Searching Venue...\" ) } NextomePhoenixState . GET_PACKET -> { updateState ( \"Downloading packet...\" ) } NextomePhoenixState . FIND_FLOOR -> { updateState ( \"Finding current Floor...\" ) } NextomePhoenixState . RUNNING -> { updateState ( \"Loading map...\" ) with ( it ) { setIndoorMap ( mapTilesUrl , mapHeight , mapWidth , venueResources . getPoisByMapId ( mapId )) } } } })","title":"Example"},{"location":"Nextome%20SDK/Android/integration/#observe-sdk-errors","text":"You can be notified of SDK errors using the appropriate observer: nextomeSdk . errorObservable . observe ( this ) { notifyException ( it . exception ) }","title":"Observe SDK errors"},{"location":"Nextome%20SDK/Android/integration/#force-a-specific-map","text":"This is expecially useful when using the Flutter Map Module. With this method you can force Nextome to show a specific map, indipendently from the user real indoor location. When this method is called, Nextome will stop sending indoor location updates. You can force a map using: nextomeSdk . setForcedMap ( mapId ) Nextome will immediatly fire a status change, localizing the user at the specified map and offering map information like tiles , height and width that you can pass to the map module. When you're done and you want to observe user real location again, call: nextomeSdk . setLiveMap ()","title":"Force a specific map"},{"location":"Nextome%20SDK/Android/integration/#example_1","text":"// Force map 42 nextomeSdk.setForcedMap(42) nextomeSdk.stateLiveData.observe(this, { when (it.state) { NextomePhoenixState.RUNNING -> { with(it) { // After forcing the map, here you can pick tiles, height and width of map 42. setIndoorMap(mapTilesUrl, mapHeight, mapWidth, venueResources.getPoisByMapId(mapId)) } } } })","title":"Example"},{"location":"Nextome%20SDK/Android/integration/#calcualte-path","text":"Nextome Sdk is able to calculate the shortest path between two points of the same venue. The function takes (x, y) coordinates and map of the starting point and (x, y) coordinates and map of the destination point. val path = nextomeSdk . findPath ( startX . toInt (), startY . toInt (), startMapId , targetX . toInt (), targetY . toInt (), targetMapId ) The returned path is a list of ordered Vertex, that, for example, can be passed to the Flutter Map Module and displayed to the user (see the methods written below).","title":"Calcualte path"},{"location":"Nextome%20SDK/Android/integration/#observe-events","text":"Info Available from nexome-sdk > 0.4.0 If events are set up in your venue, you can observe when user enters or exits from event radius using those two observers: nextomeSdk . enterEventObservable . observe ( this ) { event -> Log . d ( \"event_test\" , \"Received on enter with data: ${ event . data } \" ) } nextomeSdk . exitEventObservable . observe ( this ) { event -> Log . d ( \"event_test\" , \"Received on exit with data: ${ event . data } \" ) } Optionally, after exiting from event, it's possible to set a timeout value in seconds before signaling that event again. This allows you to ignore when user exits and enters again in a event radius in a short time span. For example, if timeout is set to 60 seconds, the same event onEnter after onExit is received will be not triggered again for at least for 1 minute. If set to 0, Nextome SDK will signal onEnter and onExit event realtime. nextomeSdk = NextomePhoenixSdk (). Builder ( applicationContext ) . withEventTimeoutDurationInSeconds ( 10L )","title":"Observe events"},{"location":"Nextome%20SDK/Android/integration/#flutter-map-module","text":"If you want, there's an optional module build with Flutter that can show a live map of the indoor location of the user. To use it, include the gradle dependency as written before in the How to include section.","title":"Flutter Map Module"},{"location":"Nextome%20SDK/Android/integration/#flutter-init","text":"A little of boilerplate code is required to initialize and set up a channel between Flutter and the native app. You can just paste this code and run it before showing the map to the user. private fun initFlutter () { val appId = \"com.nextome.test\" val engine = FlutterEngine ( this ) // Start executing Dart code in the FlutterEngine. engine . dartExecutor . executeDartEntrypoint ( DartExecutor . DartEntrypoint . createDefault () ) // Cache the pre-warmed FlutterEngine to be used later by FlutterFragment. FlutterEngineCache . getInstance () . put ( appId , engine ) val fragmentManager : FragmentManager = supportFragmentManager // Attempt to find an existing FlutterFragment, in case this is not the // first time that onCreate() was run. flutterFragment = fragmentManager . findFragmentByTag ( TAG_FLUTTER_FRAGMENT ) as FlutterFragment? // Create and attach a FlutterFragment if one does not exist. if ( flutterFragment == null ) { var newFlutterFragment = FlutterFragment . withCachedEngine ( appId ). build < FlutterFragment > () flutterFragment = newFlutterFragment fragmentManager . beginTransaction () . add ( R . id . indoor_map , newFlutterFragment , TAG_FLUTTER_FRAGMENT ). commit () } channel = MethodChannel ( engine . dartExecutor , appId ) }","title":"Flutter Init"},{"location":"Nextome%20SDK/Android/integration/#flutter-utils","text":"An utility class is available to help you with Flutter operations. If you want to comunicate with Flutter, it's suggested to include this class in your project.","title":"Flutter Utils"},{"location":"Nextome%20SDK/Android/integration/#show-a-new-indoor-map","text":"Once a map is available, pass the tiles local directory, height and width` of the map to Flutter: private fun setIndoorMap ( mapTilesUrl : String , mapHeight : Int , mapWidth : Int ) { channel . invokeMethod ( \"localPackageUrl\" , \" $ mapTilesUrl , $ mapHeight , $ mapWidth , 3\" ) }","title":"Show a new indoor map"},{"location":"Nextome%20SDK/Android/integration/#update-user-live-position","text":"When a new indoor user position is available, notify Flutter with: private fun updatePositionOnFlutterMap ( it : NextomePosition ) { channel . invokeMethod ( \"localPackageUrl\" , FlutterUtils . getLocalPackagePayload ( mapTilesUrl , mapHeight , mapWidth )) }","title":"Update user live position"},{"location":"Nextome%20SDK/Android/integration/#add-a-poi","text":"You can add custom Point of Interest on the Flutter map using this method: private fun showPoiOnMap ( poiList : List < NextomePoi > ) { channel . invokeMethod ( \"POI\" , FlutterUtils . getPoiPayload ( poiList )) }","title":"Add a POI"},{"location":"Nextome%20SDK/Android/integration/#show-a-custom-patch","text":"You can show a path on the map using this method and passing a list of Vertex. You can automatically get the Vertext between a start and end point of the map using the appropriate method on the nextomeSdk : private fun showPathOnMap ( path : List < Vertex > ) { channel . invokeMethod ( \"path\" , FlutterUtils . getPathPayload ( path )) }","title":"Show a custom patch"},{"location":"Nextome%20SDK/Android/integration/#observe-events-on-flutter-map","text":"With this observer you can be notified of events on the Flutter map, for example, when the user decides to navigate to a POI. private fun observeMapEvents () { channel . setMethodCallHandler { methodCall , _ -> // On POI \"Navigate to\" tapped if ( methodCall . method == \"poiData\" ) { val poiSerialized = methodCall . arguments as String val poi = Gson (). fromJson ( poiSerialized , FlutterPoi :: class . java ) // Ex. calculate path to POI and show it to user showPathOnMap ( lastPosition . x , lastPosition . y lastPosition . mapId , poi . x !! , poi . y !! , poi . map !! ) } } }","title":"Observe events on Flutter Map"},{"location":"Nextome%20SDK/Android/integration/#show-center-position-fab","text":"Available from flutter-map > 1.2.0 It's possible to show an optional fab at the bottom right of the map. When clicked, the button will: * center the map on the user position; * follow the user position live on map; * rotate the map based on user compass; To enable the button, use: channel . invokeMethod ( \"showCenterPositionFab\" , \"true\" ) or, if you have imported our Flutter Utils : FlutterUtils . setMapViewSettings ( channel , fabEnabled = true ) please note The compass feature will only work if the app has the following permissions: android.permission.INTERNET android.permission.ACCESS_COARSE_LOCATION android.permission.ACCESS_FINE_LOCATION If those permissions are not denied, the navigation button will only follow user position without rotating.","title":"Show Center Position Fab"},{"location":"Nextome%20SDK/Android/integration/#change-user-position-icon","text":"Info Available from flutter-map > 1.2.0 The default position icon is a blue dot. If you want to change the icon, you can load a remote resource from an url. channel . invokeMethod ( \"customPositionResourceUrl\" , \"http://nextome.net/position-icon.png\" ) or, if you're imported our Flutter Utils : FlutterUtils . setMapViewSettings ( channel , customPositionResourceUrl = \"http://nextome.net/position-icon.png\" )","title":"Change user position icon"},{"location":"Nextome%20SDK/Android/integration/#debug-tools","text":"In case of necessity, Nextome SDK can write logs with useful info to a file. You can start writing logs with nextomeSdk.startLoggingOnFile() . Those logs can then be shared using nextomeSdk.stopAndShareLog(context) . A new Intent will be fired with a share dialog that allows to export and save the logs with other apps.","title":"Debug tools"},{"location":"Nextome%20SDK/Android/integration/#examples","text":"A full working example app is available on this repository. Run the MapActivity to see Nextome Sdk in action. It also contains a seamless outdoor/indoor map integration using OpenStreetMap for outdoor and Nextome Flutter Map for indoor. \u00a9 2021 Nextome srl | All Rights Reserved.","title":"Examples"},{"location":"Nextome%20SDK/iOS/changelog/","text":"Phoenix iOS SDK Changelog Please note In order to update to a new version, write these command: pod deintegrate pod cache clean --all pod install 1.4.3 Add support for XCode 13.3; 1.4.0 Add support for events You can observe onEnter and onExit from event radius on map using those two observers: NotificationCenter . default . addObserver ( self , selector : #selector ( onDidReceiveEventEnter ( _ :)), name : NSNotification . Name ( rawValue : \"EVENT_ENTER_STREAM\" ), object : nil ) NotificationCenter . default . addObserver ( self , selector : #selector ( onDidReceiveEventExit ( _ :)), name : NSNotification . Name ( rawValue : \"EVENT_EXIT_STREAM\" ), object : nil ) Optionally, after exiting from event, it's possible to set a timeout value in seconds before signaling that event again. If set to 0, Nextome SDK will signal onEnter and onExit event realtime. self . sdk = NextomeSdk ( eventTimeout : 10 ) 1.3.2 getVersion() 1.3.1 Minor Fix New Method getVenueResource Read Here 1.3.0 Update BLE ranging feature Dependency update 1.2.0 Fix sdk log with utc time standard","title":"iOS Changelog"},{"location":"Nextome%20SDK/iOS/changelog/#phoenix-ios-sdk-changelog","text":"Please note In order to update to a new version, write these command: pod deintegrate pod cache clean --all pod install","title":"Phoenix iOS SDK Changelog"},{"location":"Nextome%20SDK/iOS/changelog/#143","text":"Add support for XCode 13.3;","title":"1.4.3"},{"location":"Nextome%20SDK/iOS/changelog/#140","text":"Add support for events You can observe onEnter and onExit from event radius on map using those two observers: NotificationCenter . default . addObserver ( self , selector : #selector ( onDidReceiveEventEnter ( _ :)), name : NSNotification . Name ( rawValue : \"EVENT_ENTER_STREAM\" ), object : nil ) NotificationCenter . default . addObserver ( self , selector : #selector ( onDidReceiveEventExit ( _ :)), name : NSNotification . Name ( rawValue : \"EVENT_EXIT_STREAM\" ), object : nil ) Optionally, after exiting from event, it's possible to set a timeout value in seconds before signaling that event again. If set to 0, Nextome SDK will signal onEnter and onExit event realtime. self . sdk = NextomeSdk ( eventTimeout : 10 )","title":"1.4.0"},{"location":"Nextome%20SDK/iOS/changelog/#132","text":"getVersion()","title":"1.3.2"},{"location":"Nextome%20SDK/iOS/changelog/#131","text":"Minor Fix New Method getVenueResource Read Here","title":"1.3.1"},{"location":"Nextome%20SDK/iOS/changelog/#130","text":"Update BLE ranging feature Dependency update","title":"1.3.0"},{"location":"Nextome%20SDK/iOS/changelog/#120","text":"Fix sdk log with utc time standard","title":"1.2.0"},{"location":"Nextome%20SDK/iOS/integration/","text":"Nextome iOS SDK - Integration Guide Requirements Swift 5 iOS 13.2 xcode 13.3 How to install Cocoapods CocoaPods is a dependency manager for Cocoa projects. For usage and installation instructions, visit their website. To integrate PhoenixSdk into your Xcode project using CocoaPods, open your terminal: ( in your home directory ) 1 ) gem install cocoapods-art 2 ) nano ~/.netrc 3 ) paste this in you .netrc file machine nextome.jfrog.io login <USERNAME> password <ENCRYPTED-PASSWORD> than close and save 3 ) pod repo-art add nextome-cocoapods-local \"https://nextome.jfrog.io/artifactory/api/pods/nextome-cocoapods-local\" If you get an error of this type: \"Permission bits, should be 0600, but are 644\" Run this command: chmod 0600 ~/.netrc Open your Podfile and add these lines: After add this pod: platform :ios, '13.0' source 'https://github.com/CocoaPods/Specs.git' plugin 'cocoapods-art', :sources => [ 'nextome-cocoapods-local' ] pod \"PhoenixSdk\", :http => 'https://nextome.jfrog.io/artifactory/nextome-cocoapods-local/nextome-sdk.tar.gz', :type => 'tgz' pod \"NextomeLegacy\", :http => 'https://nextome.jfrog.io/artifactory/nextome-cocoapods-local/nextome-sdk.tar.gz', :type => 'tgz' Then, into general tab, add this capabilities: Background Modes Uses Bluetooth LE accessories Location Updates Finally, add this line to your Info.plist Privacy - Location Always and When In Use Usage Description Privacy - Location Always Usage Description Privacy - Location When In Use Usage Description Map testing If you want only to test map, you can use x86 framework version. Remove previous integration lines and replace with these, into your podfile: pod \"PhoenixSdk_x86\", :http => 'https://nextome.jfrog.io/artifactory/nextome-cocoapods-local/nextome-sdk.tar.gz', :type => 'tgz' pod \"NextomeLegacy_x86\", :http => 'https://nextome.jfrog.io/artifactory/nextome-cocoapods-local/nextome-sdk.tar.gz', :type => 'tgz' Warning Into iOS simulator, init Nextome Sdk with override mode; specifying venue and map (you will read more details as you go along), because Simulator doesn't support Bluetooth. Replace x86 pod with arm64 before send to store, because Apple rejects all type of project which contains third party library that integrates simulator architecture. How it works PhoenixSdk is currently design with public async observer Info Observer User position POSITION_STREAM Floor change FLOOR_CHANGE Indoor/outdoor switch OUTDOOR_STREAM General Log LOG_WRITER Error ERROR Getting Started Download Nextome.plist file and insert it, into your main's app Target -> (You can download it from here: Nextome.plist ). Insert auth access keys Insert bundle data and you can adjust settings* for sdk. Settings Detail Setting Detail Particle Engine Correction of user position trajectory Position Log Send last calculate user position to Nextome server, to improve sdk Mode \"BLE\" localize user venue through beacon monitoring. \"GPS\" localize user venue through gps Binaries -Not implemented yet- Note You can modify these settings, easily calling NextomeSdk, public interface: sdkMode = \"GPS\" or \"BLE\" enableParticleEngine = true/false enableSendLog = true/false enableBinaries = true/false Import the Sdk, into your AppDelegate AppDelegate import PhoenixSdk @ main class AppDelegate : UIResponder , UIApplicationDelegate { var sdk : NextomeSdk ? ... Initialize the sdk into your AppDelegate after didFinishLaunchingWithOptions self . sdk = NextomeSdk ( device : String ? = nil , logTimer : Int ? = nil , venueId : Int ? = nil , floorId : Int ? = nil , eventTimeout : Int ? = nil ) Optional override parameter Detail device Set custom device data logTimer Customize send log to Nextome server timer venueId Ovveride venue id and skipping localization floorId Ovveride current map eventTimeout Event Trigger delay Warning If you specificy VenueId and FloorId, Sdk localization's feature will turn off. NextomeSdk will only download maps and display theme. Otherwise, if you want to init NextomeSdk with localization enabled; without customizations, you can easily do this: self . sdk = NextomeSdk () Bonus 1: User Position If you need to show, user position on virtual map, follow this step to integrate compiled flutter framework into your project. Add these lines to your PodFile. Warning Chose configuration TYPE = debug/release pod \"App_{TYPE}\", :http => 'https://nextome.jfrog.io/artifactory/nextome-cocoapods-local/flutter-map.tar.gz', :type => 'tgz' pod \"Flutter_{TYPE}\", :http => 'https://nextome.jfrog.io/artifactory/nextome-cocoapods-local/flutter-map.tar.gz', :type => 'tgz' pod \"FlutterPluginRegistrant_{TYPE}\", :http => 'https://nextome.jfrog.io/artifactory/nextome-cocoapods-local/flutter-map.tar.gz', :type => 'tgz' pod \"FMDB_{TYPE}\", :http => 'https://nextome.jfrog.io/artifactory/nextome-cocoapods-local/flutter-map.tar.gz', :type => 'tgz' pod \"path_provider_{TYPE}\", :http => 'https://nextome.jfrog.io/artifactory/nextome-cocoapods-local/flutter-map.tar.gz', :type => 'tgz' pod \"sqflite_{TYPE}\", :http => 'https://nextome.jfrog.io/artifactory/nextome-cocoapods-local/flutter-map.tar.gz', :type => 'tgz' pod \"compass_{TYPE}\", :http => 'https://nextome.jfrog.io/artifactory/nextome-cocoapods-local/flutter-map.tar.gz', :type => 'tgz' Bonus 2: Customize flutter map By default, Sdk use Compiled Nextome Flutter Map cross-plattform module, developed to display user position and indoor map. If you want to customize it, with different features or design, follow this step to integrate, Nextome Flutter Map Source files. Configure Flutter Sdk and prepare Android Studio with flutter plugins Flutter Get Started Clone into your main project's folder, Nextome Flutter Map respository Repository Open flutter_mapview module with Android Studio and run it on iOS simulator. After finish, you're now ready to integrate modules into iOS main App. Add to your PodFile flutter_application_path = '{path}/flutter_mapview' load File.join(flutter_application_path, '.ios', 'Flutter', 'podhelper.rb') install_all_flutter_pods(flutter_application_path) Run pod install Into your AppDelegate import and init Flutter engine import Flutter import FlutterPluginRegistrant var flutterEngine : FlutterEngine ? After didFinishLaunchingWithOptions self . flutterEngine = FlutterEngine ( name : \"io.flutter\" , project : nil ) self . flutterEngine ?. run ( withEntrypoint : nil ) GeneratedPluginRegistrant . register ( with : self . flutterEngine !) Into your Main View Controller prepare flutter channel, to connect iOS and Flutter Engine. import Flutter var flutterViewController : FlutterViewController ? var flutterEngine = ( UIApplication . shared . delegate as ? AppDelegate )?. flutterEngine var mapChannel = FlutterMethodChannel () flutterViewController = FlutterViewController ( engine : flutterEngine !, nibName : nil , bundle : nil ) self . mapChannel = FlutterMethodChannel ( name : \"net.nextome.phoenix\" , binaryMessenger : flutterViewController !. binaryMessenger ) Observers Open your Main View Controller and into viewDidLoad, attach to main's observers //position observer NotificationCenter . default . addObserver ( self , selector : #selector ( onDidReceivePosition ( _ :)), name : NSNotification . Name ( rawValue : \"POSITION_STREAM\" ), object : nil ) //event observer NotificationCenter . default . addObserver ( self , selector : #selector ( onDidReceiveEventEnter ( _ :)), name : NSNotification . Name ( rawValue : \"EVENT_ENTER_STREAM\" ), object : nil ) NotificationCenter . default . addObserver ( self , selector : #selector ( onDidReceiveEventExit ( _ :)), name : NSNotification . Name ( rawValue : \"EVENT_EXIT_STREAM\" ), object : nil ) //floor observer NotificationCenter . default . addObserver ( self , selector : #selector ( onDidReceiveFloorChange ( _ :)), name : NSNotification . Name ( rawValue : \"FLOOR_CHANGE\" ), object : nil ) //path observer NotificationCenter . default . addObserver ( self , selector : #selector ( onDidReceivePath ( _ :)), name : NSNotification . Name ( rawValue : \"PATH_STREAM\" ), object : nil ) //outdoor observer NotificationCenter . default . addObserver ( self , selector : #selector ( onDidReceiveOutdoor ( _ :)), name : NSNotification . Name ( rawValue : \"OUTDOOR_STREAM\" ), object : nil ) (optional) //log observer NotificationCenter . default . addObserver ( self , selector : #selector ( onDidReceiveLogs ( _ :)), name : NSNotification . Name ( rawValue : \"LOG_WRITER\" ), object : nil ) //error observer NotificationCenter . default . addObserver ( self , selector : #selector ( onDidReceiveError ( _ :)), name : NSNotification . Name ( rawValue : \"ERROR\" ), object : nil ) //Refresh Poi observer NotificationCenter . default . addObserver ( self , selector : #selector ( onRefreshPoiComplete ( _ :)), name : NSNotification . Name ( rawValue : \"REFRESHPOI_COMPLETE\" ), object : nil ) Prepares for use, onDidReceive functions, to manage Sdk data. onDidReceivePosition @objc func onDidReceivePosition ( _ notification : Notification ){ //receive position let positionData = notification . userInfo as ? [ String : [ String : Any ]] //get data let x = positionData ![ \"positionData\" ] ! [ \"x\" ] as ! String let y = positionData ![ \"positionData\" ] ! [ \"y\" ] as ! String let floor = positionData ![ \"positionData\" ] ! [ \"floor\" ] as ! String //send to flutter engine, new position's data self . mapChannel . invokeMethod ( \"position\" , arguments : x + \",\" + y ) } onDidReceiveEventEnter @objc func onDidReceiveEventEnter ( _ notification : Notification ){ //receive event let eventData = notification . userInfo as ? [ String : NextomeEvent ] let enterEvent = eventData ![ \"eventData\" ] ! } onDidReceiveEventExit @objc func onDidReceiveEventExit ( _ notification : Notification ){ //receive event let eventData = notification . userInfo as ? [ String : NextomeEvent ] let exitEvent = eventData ![ \"eventData\" ] ! } onDidReceivePath // MARK: MAP Path observer @objc func onDidReceivePath ( _ notification : Notification ){ //receive path let pathData = notification . userInfo as ? [ String : String ] if ( pathData ![ \"pathData\" ] != nil ){ if ( pathData ![ \"pathData\" ] == \"[]\" ){ //advise ui PKHUD . sharedHUD . contentView = PKHUDTextView ( text : \"Shortest path not found. Please try again\" ) PKHUD . sharedHUD . show () PKHUD . sharedHUD . dimsBackground = false PKHUD . sharedHUD . hide ( afterDelay : 2 ) { success in } } else { self . mapChannel . invokeMethod ( \"path\" , arguments : pathData ![ \"pathData\" ] ! ) } } } onDidReceiveOutdoor @objc func onDidReceiveOutdoor ( _ notification : Notification ){ //receive position let positionData = notification . userInfo as ? [ String : Double ] //get data let lat = positionData ![ \"lat\" ] ! let lng = positionData ![ \"lng\" ] ! } onDidReceiveFloorChange @objc func onDidReceiveFloorChange ( _ notification : Notification ){ //receive position let floorData = notification . userInfo as ? [ String : [ String : Any ]] //update poi let poiData = self . sdk ?. getPOIData () mapChannel . invokeMethod ( \"POI\" , arguments : poiData ) //update map's package let data = self . sdk ?. getVenueData () mapChannel . invokeMethod ( \"localPackageUrl\" , arguments : data ) } (optional) onDidReceiveError @objc func onDidReceiveError ( _ notification : Notification ){ //advise user print ( \"Errore. Riavvia l'sdk \" ) } onDidReceiveLogs @objc func onDidReceiveLogs ( _ notification : Notification ){ //get data let logInfo = notification . userInfo as ? [ String : String ] var log = logInfo ![ \"log\" ] ! } onRefreshPoiComplete @objc func onRefreshPoiComplete ( _ notification : Notification ){ //get new data and send to flutter engine let poiData = self . sdk ?. getPOIData () mapChannel . invokeMethod ( \"POI\" , arguments : poiData ) } Sdk Public Methods Start Start Sdk sdk ?. start () Stop Stop Sdk sdk ?. stop () Venue data (Flutter Utils) Get current venue package data to easily send it, to flutter engine Please note: this method returns data only if sdk state is Running sdk ?. getVenueData () -> String ? POI (Flutter Utils) Get current venue POI data to easily send it, to flutter engine Please note: this method returns data only if sdk state is Running sdk ?. getPOIData () -> String ? Refresh POI (Flutter Utils) Force Refresh current venue POI data to easily send it, to flutter engine sdk ?. refreshPOI () Refresh Map Force Refresh current displayed map Keep Attention: if you force mapId during localization, sdk locks forced map and not switchs anymore sdk ?. forceRefreshMap ( mapId : Int ) To restore map's switch, according to user position sdk ?. setLiveMap () Venue Resources (Sdk v. >= 1.3.1) Get resource bundle data, containing all Venue's Pois and Maps. Please note: this method returns data only if sdk state is Running sdk ?. getVenueResources () -> VenueResources ? Way Finding Calculate shortest route: - from user position to selected map's POI - from custom position A to custom position B and send it to flutter engine sdk ?. calculatePath_ToPOI ( poi : String ) sdk ?. calculatePath_ToCustomPoint ( point : String ) Position Get current user position data sdk ?. getPositionData () -> [ String : Any ] Report send SDK Report to Nextome admin sdk ?. sendLogReport -> Void Flutter Map Easily show flutter_map module with current venue (localized place) data //push flutter controller self . navigationController ?. pushViewController ( flutterViewController !, animated : true ) //get map's poi let poiData = self . sdk ?. getPOIData () mapChannel . invokeMethod ( \"POI\" , arguments : poiData ) //get map's resources let data = self . sdk ?. getVenueData () mapChannel . invokeMethod ( \"localPackageUrl\" , arguments : data ) //flutter callbacks mapChannel . setMethodCallHandler {( call : FlutterMethodCall , result : FlutterResult ) -> Void in // Handle poi json if call . method == \"poiData\" { //calculate path self . sdk ?. calculatePath ( poi : call . arguments as ? String ) } // Handle long press if ( call . method == \"customPosition\" ){ let customPosition = call . arguments as ! String //advise user if ( self . sdk ?. customPositionCheck == 0 ){ //advise ui PKHUD . sharedHUD . contentView = PKHUDTextView ( text : \"Start point is set\" ) PKHUD . sharedHUD . show () PKHUD . sharedHUD . hide ( afterDelay : 1.0 ) { success in } } self . sdk ?. calculateCustomPath ( point : customPosition ) } } Customization Show Center Position Fab Show FAB on Map to enable custom camera feature to live follow user position mapChannel . invokeMethod ( \"showCenterPositionFab\" , arguments : \"true\" ) Override user position icon Change user position custom icon mapChannel . invokeMethod ( \"customPositionResourceUrl\" , arguments : \"URL Png\" ) Example You can clone this repository and explore our complete Example project, to see how to manage all Sdk's data. Common issues Redefinition of Module Minizip If swift compiler report an error about redefenition of Module Minizip, you can fix in this way: Click on \"Previously defined here\" gray text Xcode will open a tab called module with some code Delete all code and rebuild the project App Distribution If you have problem with app export from xcode or AppStore distribution, follow this steps: Open your Xcode project's setting Click on Build Phase tab Add new Run Script and paste this code, which remove all x86 files and architecture from project # Type a script or drag a script file from your workspace to insert its path. APP_PATH = \" ${ TARGET_BUILD_DIR } / ${ WRAPPER_NAME } \" find \" $APP_PATH \" -name '*.framework' -type d | while read -r FRAMEWORK do FRAMEWORK_EXECUTABLE_NAME = $( defaults read \" $FRAMEWORK /Info.plist\" CFBundleExecutable ) FRAMEWORK_EXECUTABLE_PATH = \" $FRAMEWORK / $FRAMEWORK_EXECUTABLE_NAME \" echo \"Executable is $FRAMEWORK_EXECUTABLE_PATH \" echo $( lipo -info \" $FRAMEWORK_EXECUTABLE_PATH \" ) FRAMEWORK_TMP_PATH = \" $FRAMEWORK_EXECUTABLE_PATH -tmp\" case \" ${ TARGET_BUILD_DIR } \" in * \"iphonesimulator\" ) echo \"No need to remove archs\" ;; * ) if $( lipo \" $FRAMEWORK_EXECUTABLE_PATH \" -verify_arch \"i386\" ) ; then lipo -output \" $FRAMEWORK_TMP_PATH \" -remove \"i386\" \" $FRAMEWORK_EXECUTABLE_PATH \" echo \"i386 architecture removed\" rm \" $FRAMEWORK_EXECUTABLE_PATH \" mv \" $FRAMEWORK_TMP_PATH \" \" $FRAMEWORK_EXECUTABLE_PATH \" fi if $( lipo \" $FRAMEWORK_EXECUTABLE_PATH \" -verify_arch \"x86_64\" ) ; then lipo -output \" $FRAMEWORK_TMP_PATH \" -remove \"x86_64\" \" $FRAMEWORK_EXECUTABLE_PATH \" echo \"x86_64 architecture removed\" rm \" $FRAMEWORK_EXECUTABLE_PATH \" mv \" $FRAMEWORK_TMP_PATH \" \" $FRAMEWORK_EXECUTABLE_PATH \" fi ;; esac echo \"Completed for executable $FRAMEWORK_EXECUTABLE_PATH \" echo $( lipo -info \" $FRAMEWORK_EXECUTABLE_PATH \" ) done Connect with us https://www.nextome.net/ License MIT \u00a9 2020 Nextome srl | All Rights Reserved.","title":"iOS Integration"},{"location":"Nextome%20SDK/iOS/integration/#nextome-ios-sdk-integration-guide","text":"Requirements Swift 5 iOS 13.2 xcode 13.3","title":"Nextome iOS SDK - Integration Guide"},{"location":"Nextome%20SDK/iOS/integration/#how-to-install","text":"","title":"How to install"},{"location":"Nextome%20SDK/iOS/integration/#cocoapods","text":"CocoaPods is a dependency manager for Cocoa projects. For usage and installation instructions, visit their website. To integrate PhoenixSdk into your Xcode project using CocoaPods, open your terminal: ( in your home directory ) 1 ) gem install cocoapods-art 2 ) nano ~/.netrc 3 ) paste this in you .netrc file machine nextome.jfrog.io login <USERNAME> password <ENCRYPTED-PASSWORD> than close and save 3 ) pod repo-art add nextome-cocoapods-local \"https://nextome.jfrog.io/artifactory/api/pods/nextome-cocoapods-local\" If you get an error of this type: \"Permission bits, should be 0600, but are 644\" Run this command: chmod 0600 ~/.netrc Open your Podfile and add these lines: After add this pod: platform :ios, '13.0' source 'https://github.com/CocoaPods/Specs.git' plugin 'cocoapods-art', :sources => [ 'nextome-cocoapods-local' ] pod \"PhoenixSdk\", :http => 'https://nextome.jfrog.io/artifactory/nextome-cocoapods-local/nextome-sdk.tar.gz', :type => 'tgz' pod \"NextomeLegacy\", :http => 'https://nextome.jfrog.io/artifactory/nextome-cocoapods-local/nextome-sdk.tar.gz', :type => 'tgz' Then, into general tab, add this capabilities: Background Modes Uses Bluetooth LE accessories Location Updates Finally, add this line to your Info.plist Privacy - Location Always and When In Use Usage Description Privacy - Location Always Usage Description Privacy - Location When In Use Usage Description","title":"Cocoapods"},{"location":"Nextome%20SDK/iOS/integration/#map-testing","text":"If you want only to test map, you can use x86 framework version. Remove previous integration lines and replace with these, into your podfile: pod \"PhoenixSdk_x86\", :http => 'https://nextome.jfrog.io/artifactory/nextome-cocoapods-local/nextome-sdk.tar.gz', :type => 'tgz' pod \"NextomeLegacy_x86\", :http => 'https://nextome.jfrog.io/artifactory/nextome-cocoapods-local/nextome-sdk.tar.gz', :type => 'tgz' Warning Into iOS simulator, init Nextome Sdk with override mode; specifying venue and map (you will read more details as you go along), because Simulator doesn't support Bluetooth. Replace x86 pod with arm64 before send to store, because Apple rejects all type of project which contains third party library that integrates simulator architecture.","title":"Map testing"},{"location":"Nextome%20SDK/iOS/integration/#how-it-works","text":"PhoenixSdk is currently design with public async observer Info Observer User position POSITION_STREAM Floor change FLOOR_CHANGE Indoor/outdoor switch OUTDOOR_STREAM General Log LOG_WRITER Error ERROR","title":"How it works"},{"location":"Nextome%20SDK/iOS/integration/#getting-started","text":"Download Nextome.plist file and insert it, into your main's app Target -> (You can download it from here: Nextome.plist ). Insert auth access keys Insert bundle data and you can adjust settings* for sdk. Settings Detail Setting Detail Particle Engine Correction of user position trajectory Position Log Send last calculate user position to Nextome server, to improve sdk Mode \"BLE\" localize user venue through beacon monitoring. \"GPS\" localize user venue through gps Binaries -Not implemented yet- Note You can modify these settings, easily calling NextomeSdk, public interface: sdkMode = \"GPS\" or \"BLE\" enableParticleEngine = true/false enableSendLog = true/false enableBinaries = true/false Import the Sdk, into your AppDelegate AppDelegate import PhoenixSdk @ main class AppDelegate : UIResponder , UIApplicationDelegate { var sdk : NextomeSdk ? ... Initialize the sdk into your AppDelegate after didFinishLaunchingWithOptions self . sdk = NextomeSdk ( device : String ? = nil , logTimer : Int ? = nil , venueId : Int ? = nil , floorId : Int ? = nil , eventTimeout : Int ? = nil ) Optional override parameter Detail device Set custom device data logTimer Customize send log to Nextome server timer venueId Ovveride venue id and skipping localization floorId Ovveride current map eventTimeout Event Trigger delay Warning If you specificy VenueId and FloorId, Sdk localization's feature will turn off. NextomeSdk will only download maps and display theme. Otherwise, if you want to init NextomeSdk with localization enabled; without customizations, you can easily do this: self . sdk = NextomeSdk ()","title":"Getting Started"},{"location":"Nextome%20SDK/iOS/integration/#bonus-1-user-position","text":"If you need to show, user position on virtual map, follow this step to integrate compiled flutter framework into your project. Add these lines to your PodFile. Warning Chose configuration TYPE = debug/release pod \"App_{TYPE}\", :http => 'https://nextome.jfrog.io/artifactory/nextome-cocoapods-local/flutter-map.tar.gz', :type => 'tgz' pod \"Flutter_{TYPE}\", :http => 'https://nextome.jfrog.io/artifactory/nextome-cocoapods-local/flutter-map.tar.gz', :type => 'tgz' pod \"FlutterPluginRegistrant_{TYPE}\", :http => 'https://nextome.jfrog.io/artifactory/nextome-cocoapods-local/flutter-map.tar.gz', :type => 'tgz' pod \"FMDB_{TYPE}\", :http => 'https://nextome.jfrog.io/artifactory/nextome-cocoapods-local/flutter-map.tar.gz', :type => 'tgz' pod \"path_provider_{TYPE}\", :http => 'https://nextome.jfrog.io/artifactory/nextome-cocoapods-local/flutter-map.tar.gz', :type => 'tgz' pod \"sqflite_{TYPE}\", :http => 'https://nextome.jfrog.io/artifactory/nextome-cocoapods-local/flutter-map.tar.gz', :type => 'tgz' pod \"compass_{TYPE}\", :http => 'https://nextome.jfrog.io/artifactory/nextome-cocoapods-local/flutter-map.tar.gz', :type => 'tgz'","title":"Bonus 1: User Position"},{"location":"Nextome%20SDK/iOS/integration/#bonus-2-customize-flutter-map","text":"By default, Sdk use Compiled Nextome Flutter Map cross-plattform module, developed to display user position and indoor map. If you want to customize it, with different features or design, follow this step to integrate, Nextome Flutter Map Source files. Configure Flutter Sdk and prepare Android Studio with flutter plugins Flutter Get Started Clone into your main project's folder, Nextome Flutter Map respository Repository Open flutter_mapview module with Android Studio and run it on iOS simulator. After finish, you're now ready to integrate modules into iOS main App. Add to your PodFile flutter_application_path = '{path}/flutter_mapview' load File.join(flutter_application_path, '.ios', 'Flutter', 'podhelper.rb') install_all_flutter_pods(flutter_application_path) Run pod install Into your AppDelegate import and init Flutter engine import Flutter import FlutterPluginRegistrant var flutterEngine : FlutterEngine ? After didFinishLaunchingWithOptions self . flutterEngine = FlutterEngine ( name : \"io.flutter\" , project : nil ) self . flutterEngine ?. run ( withEntrypoint : nil ) GeneratedPluginRegistrant . register ( with : self . flutterEngine !) Into your Main View Controller prepare flutter channel, to connect iOS and Flutter Engine. import Flutter var flutterViewController : FlutterViewController ? var flutterEngine = ( UIApplication . shared . delegate as ? AppDelegate )?. flutterEngine var mapChannel = FlutterMethodChannel () flutterViewController = FlutterViewController ( engine : flutterEngine !, nibName : nil , bundle : nil ) self . mapChannel = FlutterMethodChannel ( name : \"net.nextome.phoenix\" , binaryMessenger : flutterViewController !. binaryMessenger )","title":"Bonus 2: Customize flutter map"},{"location":"Nextome%20SDK/iOS/integration/#observers","text":"Open your Main View Controller and into viewDidLoad, attach to main's observers //position observer NotificationCenter . default . addObserver ( self , selector : #selector ( onDidReceivePosition ( _ :)), name : NSNotification . Name ( rawValue : \"POSITION_STREAM\" ), object : nil ) //event observer NotificationCenter . default . addObserver ( self , selector : #selector ( onDidReceiveEventEnter ( _ :)), name : NSNotification . Name ( rawValue : \"EVENT_ENTER_STREAM\" ), object : nil ) NotificationCenter . default . addObserver ( self , selector : #selector ( onDidReceiveEventExit ( _ :)), name : NSNotification . Name ( rawValue : \"EVENT_EXIT_STREAM\" ), object : nil ) //floor observer NotificationCenter . default . addObserver ( self , selector : #selector ( onDidReceiveFloorChange ( _ :)), name : NSNotification . Name ( rawValue : \"FLOOR_CHANGE\" ), object : nil ) //path observer NotificationCenter . default . addObserver ( self , selector : #selector ( onDidReceivePath ( _ :)), name : NSNotification . Name ( rawValue : \"PATH_STREAM\" ), object : nil ) //outdoor observer NotificationCenter . default . addObserver ( self , selector : #selector ( onDidReceiveOutdoor ( _ :)), name : NSNotification . Name ( rawValue : \"OUTDOOR_STREAM\" ), object : nil ) (optional) //log observer NotificationCenter . default . addObserver ( self , selector : #selector ( onDidReceiveLogs ( _ :)), name : NSNotification . Name ( rawValue : \"LOG_WRITER\" ), object : nil ) //error observer NotificationCenter . default . addObserver ( self , selector : #selector ( onDidReceiveError ( _ :)), name : NSNotification . Name ( rawValue : \"ERROR\" ), object : nil ) //Refresh Poi observer NotificationCenter . default . addObserver ( self , selector : #selector ( onRefreshPoiComplete ( _ :)), name : NSNotification . Name ( rawValue : \"REFRESHPOI_COMPLETE\" ), object : nil ) Prepares for use, onDidReceive functions, to manage Sdk data.","title":"Observers"},{"location":"Nextome%20SDK/iOS/integration/#ondidreceiveposition","text":"@objc func onDidReceivePosition ( _ notification : Notification ){ //receive position let positionData = notification . userInfo as ? [ String : [ String : Any ]] //get data let x = positionData ![ \"positionData\" ] ! [ \"x\" ] as ! String let y = positionData ![ \"positionData\" ] ! [ \"y\" ] as ! String let floor = positionData ![ \"positionData\" ] ! [ \"floor\" ] as ! String //send to flutter engine, new position's data self . mapChannel . invokeMethod ( \"position\" , arguments : x + \",\" + y ) }","title":"onDidReceivePosition"},{"location":"Nextome%20SDK/iOS/integration/#ondidreceiveevententer","text":"@objc func onDidReceiveEventEnter ( _ notification : Notification ){ //receive event let eventData = notification . userInfo as ? [ String : NextomeEvent ] let enterEvent = eventData ![ \"eventData\" ] ! }","title":"onDidReceiveEventEnter"},{"location":"Nextome%20SDK/iOS/integration/#ondidreceiveeventexit","text":"@objc func onDidReceiveEventExit ( _ notification : Notification ){ //receive event let eventData = notification . userInfo as ? [ String : NextomeEvent ] let exitEvent = eventData ![ \"eventData\" ] ! }","title":"onDidReceiveEventExit"},{"location":"Nextome%20SDK/iOS/integration/#ondidreceivepath","text":"// MARK: MAP Path observer @objc func onDidReceivePath ( _ notification : Notification ){ //receive path let pathData = notification . userInfo as ? [ String : String ] if ( pathData ![ \"pathData\" ] != nil ){ if ( pathData ![ \"pathData\" ] == \"[]\" ){ //advise ui PKHUD . sharedHUD . contentView = PKHUDTextView ( text : \"Shortest path not found. Please try again\" ) PKHUD . sharedHUD . show () PKHUD . sharedHUD . dimsBackground = false PKHUD . sharedHUD . hide ( afterDelay : 2 ) { success in } } else { self . mapChannel . invokeMethod ( \"path\" , arguments : pathData ![ \"pathData\" ] ! ) } } }","title":"onDidReceivePath"},{"location":"Nextome%20SDK/iOS/integration/#ondidreceiveoutdoor","text":"@objc func onDidReceiveOutdoor ( _ notification : Notification ){ //receive position let positionData = notification . userInfo as ? [ String : Double ] //get data let lat = positionData ![ \"lat\" ] ! let lng = positionData ![ \"lng\" ] ! }","title":"onDidReceiveOutdoor"},{"location":"Nextome%20SDK/iOS/integration/#ondidreceivefloorchange","text":"@objc func onDidReceiveFloorChange ( _ notification : Notification ){ //receive position let floorData = notification . userInfo as ? [ String : [ String : Any ]] //update poi let poiData = self . sdk ?. getPOIData () mapChannel . invokeMethod ( \"POI\" , arguments : poiData ) //update map's package let data = self . sdk ?. getVenueData () mapChannel . invokeMethod ( \"localPackageUrl\" , arguments : data ) } (optional)","title":"onDidReceiveFloorChange"},{"location":"Nextome%20SDK/iOS/integration/#ondidreceiveerror","text":"@objc func onDidReceiveError ( _ notification : Notification ){ //advise user print ( \"Errore. Riavvia l'sdk \" ) }","title":"onDidReceiveError"},{"location":"Nextome%20SDK/iOS/integration/#ondidreceivelogs","text":"@objc func onDidReceiveLogs ( _ notification : Notification ){ //get data let logInfo = notification . userInfo as ? [ String : String ] var log = logInfo ![ \"log\" ] ! }","title":"onDidReceiveLogs"},{"location":"Nextome%20SDK/iOS/integration/#onrefreshpoicomplete","text":"@objc func onRefreshPoiComplete ( _ notification : Notification ){ //get new data and send to flutter engine let poiData = self . sdk ?. getPOIData () mapChannel . invokeMethod ( \"POI\" , arguments : poiData ) }","title":"onRefreshPoiComplete"},{"location":"Nextome%20SDK/iOS/integration/#sdk-public-methods","text":"","title":"Sdk Public Methods"},{"location":"Nextome%20SDK/iOS/integration/#start","text":"Start Sdk sdk ?. start ()","title":"Start"},{"location":"Nextome%20SDK/iOS/integration/#stop","text":"Stop Sdk sdk ?. stop ()","title":"Stop"},{"location":"Nextome%20SDK/iOS/integration/#venue-data-flutter-utils","text":"Get current venue package data to easily send it, to flutter engine Please note: this method returns data only if sdk state is Running sdk ?. getVenueData () -> String ?","title":"Venue data (Flutter Utils)"},{"location":"Nextome%20SDK/iOS/integration/#poi-flutter-utils","text":"Get current venue POI data to easily send it, to flutter engine Please note: this method returns data only if sdk state is Running sdk ?. getPOIData () -> String ?","title":"POI (Flutter Utils)"},{"location":"Nextome%20SDK/iOS/integration/#refresh-poi-flutter-utils","text":"Force Refresh current venue POI data to easily send it, to flutter engine sdk ?. refreshPOI ()","title":"Refresh POI (Flutter Utils)"},{"location":"Nextome%20SDK/iOS/integration/#refresh-map","text":"Force Refresh current displayed map Keep Attention: if you force mapId during localization, sdk locks forced map and not switchs anymore sdk ?. forceRefreshMap ( mapId : Int ) To restore map's switch, according to user position sdk ?. setLiveMap ()","title":"Refresh Map"},{"location":"Nextome%20SDK/iOS/integration/#venue-resources-sdk-v-131","text":"Get resource bundle data, containing all Venue's Pois and Maps. Please note: this method returns data only if sdk state is Running sdk ?. getVenueResources () -> VenueResources ?","title":"Venue Resources (Sdk v. &gt;= 1.3.1)"},{"location":"Nextome%20SDK/iOS/integration/#way-finding","text":"Calculate shortest route: - from user position to selected map's POI - from custom position A to custom position B and send it to flutter engine sdk ?. calculatePath_ToPOI ( poi : String ) sdk ?. calculatePath_ToCustomPoint ( point : String )","title":"Way Finding"},{"location":"Nextome%20SDK/iOS/integration/#position","text":"Get current user position data sdk ?. getPositionData () -> [ String : Any ]","title":"Position"},{"location":"Nextome%20SDK/iOS/integration/#report","text":"send SDK Report to Nextome admin sdk ?. sendLogReport -> Void","title":"Report"},{"location":"Nextome%20SDK/iOS/integration/#flutter-map","text":"Easily show flutter_map module with current venue (localized place) data //push flutter controller self . navigationController ?. pushViewController ( flutterViewController !, animated : true ) //get map's poi let poiData = self . sdk ?. getPOIData () mapChannel . invokeMethod ( \"POI\" , arguments : poiData ) //get map's resources let data = self . sdk ?. getVenueData () mapChannel . invokeMethod ( \"localPackageUrl\" , arguments : data ) //flutter callbacks mapChannel . setMethodCallHandler {( call : FlutterMethodCall , result : FlutterResult ) -> Void in // Handle poi json if call . method == \"poiData\" { //calculate path self . sdk ?. calculatePath ( poi : call . arguments as ? String ) } // Handle long press if ( call . method == \"customPosition\" ){ let customPosition = call . arguments as ! String //advise user if ( self . sdk ?. customPositionCheck == 0 ){ //advise ui PKHUD . sharedHUD . contentView = PKHUDTextView ( text : \"Start point is set\" ) PKHUD . sharedHUD . show () PKHUD . sharedHUD . hide ( afterDelay : 1.0 ) { success in } } self . sdk ?. calculateCustomPath ( point : customPosition ) } }","title":"Flutter Map"},{"location":"Nextome%20SDK/iOS/integration/#customization","text":"","title":"Customization"},{"location":"Nextome%20SDK/iOS/integration/#show-center-position-fab","text":"Show FAB on Map to enable custom camera feature to live follow user position mapChannel . invokeMethod ( \"showCenterPositionFab\" , arguments : \"true\" )","title":"Show Center Position Fab"},{"location":"Nextome%20SDK/iOS/integration/#override-user-position-icon","text":"Change user position custom icon mapChannel . invokeMethod ( \"customPositionResourceUrl\" , arguments : \"URL Png\" )","title":"Override user position icon"},{"location":"Nextome%20SDK/iOS/integration/#example","text":"You can clone this repository and explore our complete Example project, to see how to manage all Sdk's data.","title":"Example"},{"location":"Nextome%20SDK/iOS/integration/#common-issues","text":"","title":"Common issues"},{"location":"Nextome%20SDK/iOS/integration/#redefinition-of-module-minizip","text":"If swift compiler report an error about redefenition of Module Minizip, you can fix in this way: Click on \"Previously defined here\" gray text Xcode will open a tab called module with some code Delete all code and rebuild the project","title":"Redefinition of Module Minizip"},{"location":"Nextome%20SDK/iOS/integration/#app-distribution","text":"If you have problem with app export from xcode or AppStore distribution, follow this steps: Open your Xcode project's setting Click on Build Phase tab Add new Run Script and paste this code, which remove all x86 files and architecture from project # Type a script or drag a script file from your workspace to insert its path. APP_PATH = \" ${ TARGET_BUILD_DIR } / ${ WRAPPER_NAME } \" find \" $APP_PATH \" -name '*.framework' -type d | while read -r FRAMEWORK do FRAMEWORK_EXECUTABLE_NAME = $( defaults read \" $FRAMEWORK /Info.plist\" CFBundleExecutable ) FRAMEWORK_EXECUTABLE_PATH = \" $FRAMEWORK / $FRAMEWORK_EXECUTABLE_NAME \" echo \"Executable is $FRAMEWORK_EXECUTABLE_PATH \" echo $( lipo -info \" $FRAMEWORK_EXECUTABLE_PATH \" ) FRAMEWORK_TMP_PATH = \" $FRAMEWORK_EXECUTABLE_PATH -tmp\" case \" ${ TARGET_BUILD_DIR } \" in * \"iphonesimulator\" ) echo \"No need to remove archs\" ;; * ) if $( lipo \" $FRAMEWORK_EXECUTABLE_PATH \" -verify_arch \"i386\" ) ; then lipo -output \" $FRAMEWORK_TMP_PATH \" -remove \"i386\" \" $FRAMEWORK_EXECUTABLE_PATH \" echo \"i386 architecture removed\" rm \" $FRAMEWORK_EXECUTABLE_PATH \" mv \" $FRAMEWORK_TMP_PATH \" \" $FRAMEWORK_EXECUTABLE_PATH \" fi if $( lipo \" $FRAMEWORK_EXECUTABLE_PATH \" -verify_arch \"x86_64\" ) ; then lipo -output \" $FRAMEWORK_TMP_PATH \" -remove \"x86_64\" \" $FRAMEWORK_EXECUTABLE_PATH \" echo \"x86_64 architecture removed\" rm \" $FRAMEWORK_EXECUTABLE_PATH \" mv \" $FRAMEWORK_TMP_PATH \" \" $FRAMEWORK_EXECUTABLE_PATH \" fi ;; esac echo \"Completed for executable $FRAMEWORK_EXECUTABLE_PATH \" echo $( lipo -info \" $FRAMEWORK_EXECUTABLE_PATH \" ) done","title":"App Distribution"},{"location":"Nextome%20SDK/iOS/integration/#connect-with-us","text":"https://www.nextome.net/","title":"Connect with us"},{"location":"Nextome%20SDK/iOS/integration/#license","text":"MIT \u00a9 2020 Nextome srl | All Rights Reserved.","title":"License"}]}